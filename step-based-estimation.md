# Методология Step-Based Estimation (SBE)

## Описание методологии

**Step-Based Estimation** — подход к планированию разработки, при котором каждая задача декомпозируется на детальные, конкретные шаги выполнения с последующим анализом зависимостей и возможностью ретроспективного сравнения плана с фактом.

В дополнение к Acceptance Criteria, которые как правило являются декларативным представлением задачи, Implementation Steps — это императивное описание того, как именно задача будет реализована.

### Процесс SBE:

**Организация работы:**

- **Refinement сессия**: Обычная эстимация задач через agile poker
- **Step Estimation сессия**: Отдельная встреча для детальной декомпозиции

**Выбор задач для детализации**: На Step Estimation выносятся задачи по результатам голосования команды

**Этапы работы над задачей:**

1. **Декомпозиция**: Разбить задачу на конкретные шаги ("Добавить поле X в форму Y", "Обновить функцию Z в модуле W", "Создать репозиторий для источника данных Y")
2. **Поиск скрытых подзадач**: Выявить шаги, которые могут быть вынесены в отдельные задачи.
3. **Создание подзадач**: Выделить отдельные задачи из сложных или независимых шагов.
4. **Анализ затрагиваемых сущностей**: Определить количество классов, функций, модулей, репозиториев, источников данных, методов и необходимых тестов
5. **Эстимация**: Оценить задачу по общему количеству шагов (используя Фибоначчи).
6. **Выполнение**: Отмечать выполненные шаги
7. **Ретроспектива** _(опционально)_: Сравнить запланированные шаги с фактически выполненными, выявить паттерны расхождений и улучшить будущие оценки

---

## Сравнение подходов к эстимации

### Refinement (оптимистичная оценка)

**Характер:** Высокоуровневая, быстрая, основана на общем понимании

**Когда возникает:**

- На начальном этапе планирования
- При первом знакомстве с задачей
- Основана на Acceptance Criteria

**Особенности оценки:**

- ✓ Быстрая (5-10 минут на задачу)
- ✓ Вовлекает всю команду
- ⚠ Склонна к недооценке сложности
- ⚠ Не учитывает детали реализации
- ⚠ Пропускает "скрытые" шаги (настройка окружения, рефакторинг, edge cases)

**Типичные вопросы:**

- "Это примерно как та задача?"
- "Звучит как 5 поинтов"
- "Acceptance Criteria выглядят простыми"

**Пример оценки:**

```
Задача: "Добавить экспорт отчетов в PDF"
Мышление: "Ну, подключим библиотеку, сделаем кнопку,
напишем пару методов — 3 поинта"
Оценка: 3 SP
```

### Step Estimation (пессимистичная оценка)

**Характер:** Детальная, реалистичная, основана на конкретных шагах реализации

**Когда возникает:**

- После Refinement, перед началом спринта
- Для сложных/рискованных задач
- Основана на Implementation Steps

**Особенности оценки:**

- ✓ Учитывает детали и edge cases
- ✓ Выявляет скрытые шаги
- ✓ Более реалистична
- ⚠ Требует больше времени (15-25 минут на задачу)
- ⚠ Требует технической экспертизы

**Типичные вопросы:**

- "Какие классы, модули и функции нужно будет изменить?"
- "Какие репозитории и источники данных затронуты?"
- "Сколько тестов придется написать?"
- "Что может пойти не так?"
- "Какие зависимости между шагами?"

**Пример оценки:**

```
Задача: "Добавить экспорт отчетов в PDF"
Мышление: "Нужно выбрать библиотеку, настроить шрифты,
обработать таблицы, графики, пагинацию, стили,
написать тесты для разных форматов данных,
добавить обработку ошибок при больших файлах,
настроить memory limits, добавить прогресс-бар..."
Оценка: 5-8 SP
```

---

## Синергия двух подходов

### Классическая проблема (только Refinement)

```
Команда на Refinement: "Добавить фильтры в таблицу — 3 поинта!"

Реальность в спринте:
- День 1: "Ой, нужно переделать структуру базы данных"
- День 2: "Ой, нужно добавить индексы для производительности"
- День 3: "Ой, нужно обработать edge cases с пустыми данными"
- День 4: "Ой, нужно адаптировать UI под мобильные устройства"
- День 5: "Ой, нужно написать 15 тестов вместо 5"

Результат: 3 SP превратились в 8 SP, задача не влезла в спринт
```

### С применением SBE (Refinement + Step Estimation)

```
Refinement (оптимистичная): 3 SP
↓
Голосование команды: вынести на Step Estimation
↓
Step Estimation (пессимистичная): детализация выявляет:
- 12 шагов вместо предполагаемых 5
- Нужна миграция БД
- Потребуется 15 тестов
- Затрагивается 6 классов
↓
Корректировка: 3 SP → 5 SP
↓
Результат: реалистичная оценка, задача влезает в спринт
```

### Психология эстимации

**Refinement (оптимизм):**

- Команда фокусируется на "happy path"
- "Мы уже делали похожее, будет быстро"
- Недооценка сложности — естественная когнитивная ошибка

**Step Estimation (реализм):**

- Детализация заставляет думать о проблемах
- "А что если...", "Нужно учесть..."
- Выявление скрытых сложностей

**Баланс:**
Оптимистичная оценка на Refinement → быстрое планирование бэклога
Пессимистичная оценка на Step Estimation → реалистичное планирование спринта

---

## Преимущества подхода

### 1. **Повышение точности эстимаций**

- Детализация выявляет скрытые подзадачи на этапе планирования
- Накапливается база знаний о реальной трудозатратности типовых шагов
- Снижается влияние оптимизма и когнитивных искажений

### 2. **Улучшение планирования спринта**

- Возможность распараллеливания независимых шагов
- Выявление критического пути проекта
- Более равномерная загрузка команды

### 3. **Структурированная ретроспектива** _(опционально)_

- Конкретные данные вместо субъективных ощущений
- Выявление системных проблем в процессах
- Материал для улучшения будущих эстимаций

### 4. **Снижение рисков**

- Раннее выявление зависимостей между задачами
- Предотвращение "забытых" шагов (тесты, документация, деплой)
- Возможность раннего перепланирования при отклонениях

### 5. **Прозрачность прогресса**

- Более детальное отслеживание готовности задач
- Раннее выявление блокеров и проблем
- Улучшенная коммуникация с заказчиками

### 6. **Предварительная оценка тестового покрытия**

- Определение количества затрагиваемых программных сущностей (классы, функции, модули, репозитории, источники данных)
- Поверхностная оценка объема необходимых юнит-тестов для каждого типа сущности
- Планирование усилий на тестирование на этапе эстимации
- Оценка интеграционных тестов для взаимодействия между модулями и источниками данных

---

## Организация процесса

### Refinement сессия (стандартная)

**Цель:** Первичная оценка задач бэклога

**Участники:** Вся команда разработки

**Процесс:**

1. Product Owner представляет задачу
2. Обсуждение Acceptance Criteria
3. Уточняющие вопросы
4. Эстимация через agile poker (Planning Poker)
5. Фиксация оценки в story points

**Длительность:** 1-2 часа

**Характер оценки:** Оптимистичная, быстрая, высокоуровневая

### Step Estimation сессия (дополнительная)

**Цель:** Детальная декомпозиция сложных задач

**Участники:**

- Обязательно: разработчики, которые будут работать над задачей
- Желательно: Tech Lead, QA Engineer
- Опционально: Product Owner (для уточнения требований)

**Выбор задач для детализации:**
Команда голосует за задачи, которые нуждаются в детализации:

- Задачи с высокой неопределенностью
- Задачи 5+ story points
- Задачи, затрагивающие критичные компоненты
- Задачи с техническими рисками
- Задачи, где оценка на Refinement вызвала споры

**Процесс:**

1. Выбор задачи для детализации (по результатам голосования)
2. Декомпозиция на Implementation Steps
3. Анализ затрагиваемых программных сущностей (классы, функции, модули, репозитории, источники данных)
4. Оценка количества необходимых тестов
5. Выявление зависимостей между шагами
6. Возможность корректировки первоначальной оценки
7. Переход к следующей задаче

**Длительность:** 1-1.5 часа (обычно детализируется 3-5 задач)

**Частота:** 1 раз в спринт или по необходимости

**Характер оценки:** Пессимистичная, детальная, реалистичная

---

## Практические примеры

### Пример 1: Эффект оптимизма vs реализма

**Задача:** "Добавить двухфакторную аутентификацию"

**Refinement (оптимистичная оценка):**

```
Обсуждение (5 минут):
Dev 1: "Нужно добавить поле в базу, сделать форму, подключить библиотеку TOTP"
Dev 2: "Да, звучит как средняя задача"
Dev 3: "Мы уже делали похожее с email подтверждением"
PO: "Acceptance Criteria простые: включить, отключить, использовать при входе"

Голосование: 5, 5, 5, 8
Консенсус: 5 SP

Мышление: "Основной функционал понятен, библиотека все сделает"
```

**Step Estimation (пессимистичная оценка):**

```
Детализация (20 минут):

Implementation Steps:
1. Создать миграцию для поля two_factor_secret в таблице users
2. Добавить поле two_factor_enabled (boolean)
3. Добавить методы enable2FA/disable2FA в User модель
4. Установить библиотеку для генерации TOTP кодов
5. Изучить документацию библиотеки для edge cases
6. Создать контроллер TwoFactorController
7. Реализовать генерацию QR-кода для настройки
8. Добавить проверку TOTP при логине в AuthController
9. Обработать случай, когда пользователь потерял устройство
10. Создать систему резервных кодов восстановления
11. Создать UI для включения/отключения 2FA
12. Создать UI для показа QR-кода
13. Создать UI для показа резервных кодов
14. Добавить rate limiting для попыток ввода кода
15. Написать unit-тесты для User модели (4 теста)
16. Написать тесты для TwoFactorController (5 тестов)
17. Написать тесты для BackupCodeService (3 теста)
18. Написать интеграционные тесты (3 теста)
19. Обновить документацию API
20. Протестировать на разных устройствах
21. Протестировать интеграцию с мобильными приложениями

Затрагиваемые сущности:
- User модель/класс (2 новых метода)
- AuthController (модификация функции login)
- TwoFactorController (новый класс, 5 методов)
- BackupCodeService (новый сервисный модуль, 3 функции)
- TwoFactorMiddleware (новый middleware модуль)
- UserRepository (модификация для работы с 2FA полями)
- Database (источник данных: новые поля в таблице users)
- 3 новых UI компонента

Тесты: ~15 unit + 3 интеграционных = 18 тестов

Обсуждение:
Dev 1: "О, я забыл про резервные коды при первой оценке"
Dev 2: "И про rate limiting тоже не подумал"
Dev 3: "Тестирование займет больше времени, чем я думал"
Tech Lead: "Плюс нужно учесть безопасность и edge cases"

Переоценка: 5 SP → 8 SP

Мышление: "Когда начинаешь детализировать, понимаешь реальный объем работы"
```

### Пример 2: Корректировка после детализации

**Задача:** "Добавить экспорт отчетов в PDF и Excel"

**Refinement (оптимистичная):**

```
Команда: "Библиотеки для PDF и Excel есть готовые,
просто подключим и сделаем кнопку экспорта"

Оценка: 3 SP
```

**Step Estimation (пессимистичная):**

```
Детализация выявила:

1. Выбор библиотек (исследование):
   - Сравнить 3 PDF библиотеки
   - Сравнить 2 Excel библиотеки
   - Проверить лицензии

2. PDF экспорт (8 шагов):
   - Настроить библиотеку
   - Настроить шрифты (кириллица!)
   - Обработать таблицы
   - Обработать графики
   - Настроить пагинацию
   - Добавить стили компании (логотип, цвета)
   - Оптимизировать размер файла
   - Тесты (4 теста)

3. Excel экспорт (6 шагов):
   - Настроить библиотеку
   - Экспорт данных таблицы
   - Форматирование ячеек
   - Формулы для итоговых строк
   - Защита листов
   - Тесты (3 теста)

4. UI и интеграция (5 шагов):
   - Добавить кнопки экспорта
   - Добавить выбор формата
   - Прогресс-бар для больших отчетов
   - Обработка ошибок
   - Тесты UI (2 теста)

5. Производительность (3 шага):
   - Фоновая генерация для больших файлов
   - Ограничения на размер данных
   - Очистка временных файлов

6. Документация и edge cases (3 шага):
   - Обновить пользовательскую документацию
   - Тестирование с граничными объемами данных
   - Тестирование с различными браузерами

Итого: 25+ шагов, 9+ тестов

Затрагиваемые сущности:
- 3 новых класса (PDFExporter, ExcelExporter, ExportController)
- 2 новых модуля (FileGenerationModule, ProgressTrackingModule)
- 4 новые функции в существующих модулях
- 1 новый репозиторий (ExportRepository)
- 2 источника данных (временные файлы, очередь задач)
- 3 модификации существующих компонентов

Обсуждение:
Dev: "О, я совсем забыл про кириллицу в PDF..."
QA: "А как обрабатываем ситуацию с миллионом строк?"
Tech Lead: "Нужна будет фоновая обработка, это отдельная задача"

Решение: Разбить на 2 задачи:
- "PDF экспорт" - 5 SP
- "Excel экспорт" - 3 SP
Вместо изначальных 3 SP для всего
```

### Пример 3: Голосование за задачи на Step Estimation

**Ситуация:** У команды в спринте 12 задач после Refinement

**Кандидаты на детализацию:**

```
1. "Добавить 2FA" - 8 SP ✓✓✓✓✓✓ (6 голосов)
   Причины: критичная безопасность, сложная интеграция
   Оценка кажется слишком оптимистичной

2. "Рефакторинг уведомлений" - 5 SP ✓✓✓✓✓ (5 голосов)
   Причины: рефакторинг, затрагивает много кода
   На Refinement были разногласия в оценках (3,5,5,8)

3. "Интеграция с платежным API" - 8 SP ✓✓✓✓ (4 голоса)
   Причины: внешняя зависимость, высокий риск
   Никто не работал с этим API раньше

4. "Добавить фильтры в таблицу" - 5 SP ✓✓ (2 голоса)
   Причины: типовая задача, низкий риск
   Команда уверена в оценке

5. "Обновить дизайн кнопок" - 2 SP ✓ (1 голос)
   Причины: простая задача
   Оценка очевидна
```

**Решение команды:**
На Step Estimation выносятся топ-3 задачи (1, 2, 3).
Задачи 4 и 5 выполняются без детализации как типовые.

**Результаты Step Estimation:**

```
1. "Добавить 2FA": 8 SP → 8 SP (подтверждена, но добавлена детализация)
2. "Рефакторинг уведомлений": 5 SP → 8 SP (переоценена вверх!)
3. "Интеграция с платежным API": 8 SP → 5 SP (переоценена вниз,
   оказалось что API проще чем казалось)

Общий эффект: более точное планирование capacity спринта
```

### Пример 4: Оптимизация через анализ зависимостей

**Задача после Step Estimation:** "Интеграция с платежным API" (5 SP)

```
Implementation Steps с анализом зависимостей:

Блок A (Backend Core) - последовательные:
1. Изучить API документацию провайдера (1 день)
2. Создать PaymentGateway класс
3. Реализовать метод createPayment()

Блок B (Webhooks) - зависит от A.2:
4. Реализовать webhook controller
5. Настроить роуты для webhooks

Блок C (Error Handling) - зависит от A.3:
6. Добавить обработку ошибок платежей
7. Добавить логирование и алерты

Блок D (Integration) - зависит от A.3, B.4:
8. Интегрировать в OrderController
9. Добавить обработку callback'ов

Блок E (Frontend) - можно параллельно с A,B:
10. Создать UI для выбора способа оплаты
11. Добавить прогресс-бар обработки платежа

Блок F (Testing) - зависит от всего:
12. Написать unit-тесты с моками
13. Протестировать на staging с реальным API

Оптимизированный план:
День 1-2: A.1,2,3 || E.10,11 (параллельно)
День 3: B.4,5 || C.6,7 (параллельно после A.3)
День 4: D.8,9 (после B и C)
День 5: F.12,13 (финальное тестирование)
```

**Результат:** Вместо последовательных 8 дней — 5 дней с распараллеливанием

---

## Уровни применения методологии

SBE можно применять с разной степенью детализации в зависимости от потребностей команды:

### Базовый уровень (минимальное внедрение)

**Что делаем:**

- Проводим Refinement + Step Estimation сессии
- Декомпозируем задачи на конкретные шаги
- Анализируем зависимости для параллелизации
- Считаем затрагиваемые сущности (классы, функции, модули, репозитории, источники данных) и тесты

**Что получаем:**

- Более точные эстимации
- Лучшее планирование спринта
- Предсказуемость объема тестирования
- Баланс между оптимизмом Refinement и реализмом Step Estimation

**Трудозатраты:** +10-15% времени на планирование (дополнительная 1.5 часа Step Estimation)

### Продвинутый уровень (с ретроспективой)

**Дополнительно делаем:**

- Фиксируем фактически выполненные шаги
- Сравниваем план с фактом
- Анализируем паттерны расхождений
- Создаем шаблоны для типовых задач

**Дополнительно получаем:**

- Постоянное улучшение точности эстимаций
- База знаний команды о типовых задачах
- Выявление системных проблем в процессе

**Дополнительные трудозатраты:** +5-10% времени на ретроспективу

---

## Внедрение методологии

### Начальный этап (1-2 спринта) - Базовый уровень

**Организационные изменения:**

- Добавить Step Estimation сессию в календарь команды (1-1.5 часа/спринт)
- Определить критерии для голосования за задачи
- Создать шаблон для фиксации Implementation Steps

**Процесс:**

- Выбрать 2-3 задачи на Step Estimation по голосованию
- Фокус на декомпозиции и анализе зависимостей
- Подсчет затрагиваемых программных сущностей (классы, функции, модули, репозитории, источники данных, методы)
- Оценка необходимого тестового покрытия
- Сравнение оптимистичных и пессимистичных оценок

### Развитие (3-6 спринтов) - Можно добавить ретроспективу

- Расширить количество детализируемых задач (до 5-7)
- Создание шаблонов для повторяющихся типов задач
- _(Опционально)_ Начать сбор данных: planned vs actual
- _(Опционально)_ Анализ паттернов расхождений
- Внедрение инструментов для автоматизации

### Зрелость (6+ спринтов) - Полное использование

- Предиктивная аналитика на основе исторических данных
- Автоматические рекомендации по декомпозиции
- Интеграция с CI/CD для автоматической отметки шагов
- Автоматическая оценка тестового покрытия по типу задачи
- Возможность детализации большинства задач спринта

---

## ROI методологии

### Базовый уровень

**Инвестиции:** +10-15% времени на планирование (дополнительная 1.5 часа Step Estimation)

**Возврат:**

- Снижение overrun'ов
- Улучшение планирования тестирования
- Повышение предсказуемости сроков

### Продвинутый уровень

**Инвестиции:** +15-25% времени на планирование и ретроспективу

**Возврат:**

- Дополнительное снижение overrun'ов
- Постоянное улучшение процессов
- Накопление базы знаний команды
- Сокращение времени на аналогичные задачи в будущем
